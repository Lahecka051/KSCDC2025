"""
drone_main_controller.py

드론의 비행 컴퓨터(Companion Computer)에서 실행되는 메인 컨트롤러.
- MAVSDK를 통해 FC와 연결하고 제어합니다.
- UART 포트를 통해 원격 제어 명령을 수신하고, 드론의 텔레메트리 데이터를 송신합니다.
- 자동 상승/하강 테스트 시퀀스를 포함합니다.
"""
import asyncio
import logging
import serial
import json
import threading
import queue
from datetime import datetime
from typing import Literal

from mavsdk import System
from pydantic import BaseModel, Field, ValidationError

# --- 기본 설정: 로깅 ---
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)

# --- 드론 연결 클래스 (MAVSDK 담당) ---
class DroneConnection:
    """MAVSDK를 사용하여 드론에 연결하고 기본 상태를 관리"""
    def __init__(self, connection_string="udp://:14540"):
        self.drone = System()
        self.connection_string = connection_string
        self.is_connected = False
        self.logger = logging.getLogger(self.__class__.__name__)
        self.latest_telemetry = {}
        self._telemetry_task = None

    async def connect(self, timeout=20.0):
        self.logger.info(f"FC에 연결을 시도합니다: {self.connection_string}")
        await self.drone.connect(system_address=self.connection_string)
        try:
            await asyncio.wait_for(self._wait_for_connection(), timeout=timeout)
            self.is_connected = True
            self._telemetry_task = asyncio.create_task(self._monitor_telemetry())
            self.logger.info("드론 연결 및 텔레메트리 모니터링 시작.")
            return True
        except asyncio.TimeoutError:
            self.logger.error("연결 시간 초과! FC 전원 및 설정을 확인하세요.")
            return False

    async def _wait_for_connection(self):
        async for state in self.drone.core.connection_state():
            if state.is_connected:
                self.logger.info("FC 발견 및 연결 성공!"); return

    async def _monitor_telemetry(self):
        """주요 텔레메트리를 비동기적으로 수집하여 저장소에 업데이트"""
        async def monitor_stream(stream, key):
            async for value in stream: self.latest_telemetry[key] = value
        
        # 필요한 텔레메트리만 스트리밍하여 효율성 증대
        tasks = [
            monitor_stream(self.drone.telemetry.position(), 'position'),
            monitor_stream(self.drone.telemetry.attitude_euler(), 'attitude'),
            monitor_stream(self.drone.telemetry.battery(), 'battery'),
        ]
        await asyncio.gather(*tasks)

    async def disconnect(self):
        if self._telemetry_task: self._telemetry_task.cancel()
        self.logger.info("드론 연결 해제됨.")

# --- 통합 UART 통신 클래스 ---
class UnifiedUARTComm:
    """단일 UART 포트로 데이터 송수신을 관리"""
    def __init__(self, uart_port="/dev/ttyTHS0", baudrate=115200):
        self.serial_conn = None
        self.uart_port = uart_port
        self.baudrate = baudrate
        self.logger = logging.getLogger(self.__class__.__name__)
        self.command_queue = queue.Queue()
        self.is_running = False
        self.rx_thread = None

    def start(self):
        try:
            self.serial_conn = serial.Serial(port=self.uart_port, baudrate=self.baudrate, timeout=0.1)
            self.is_running = True
            self.rx_thread = threading.Thread(target=self._rx_loop, daemon=True)
            self.rx_thread.start()
            self.logger.info(f"통합 UART 통신 시작: {self.uart_port}")
            return True
        except serial.SerialException as e:
            self.logger.error(f"UART 포트({self.uart_port})를 열 수 없습니다: {e}")
            return False

    def stop(self):
        self.is_running = False
        if self.rx_thread: self.rx_thread.join(timeout=1.0)
        if self.serial_conn and self.serial_conn.is_open: self.serial_conn.close()
        self.logger.info("통합 UART 통신 중지.")

    def _rx_loop(self):
        buffer = ""
        while self.is_running:
            try:
                if self.serial_conn.in_waiting > 0:
                    buffer += self.serial_conn.read(self.serial_conn.in_waiting).decode('utf-8', errors='ignore')
                    while '\n' in buffer:
                        line, buffer = buffer.split('\n', 1)
                        if line: self.command_queue.put(line)
            except Exception as e:
                self.logger.error(f"UART 수신 오류: {e}")
            threading.Event().wait(0.01)

    def send_data(self, data_type: str, payload: dict):
        if not self.is_running: return
        try:
            message = {'type': data_type, 'timestamp': datetime.now().isoformat(), 'payload': payload}
            json_str = json.dumps(message, default=str) + '\n' # 객체를 문자열로 변환
            self.serial_conn.write(json_str.encode('utf-8'))
        except Exception as e:
            self.logger.error(f"UART 송신 오류 ({data_type}): {e}")

    def get_command(self):
        try:
            return self.command_queue.get_nowait()
        except queue.Empty:
            return None

# --- 제어 명령 유효성 검증 모델 ---
class ControlCommand(BaseModel):
    """Pydantic을 이용한 제어 명령 유효성 검증 모델"""
    vertical: Literal["up", "level", "down"] = "level"
    horizontal: Literal["hover", "forward", "backward", "left", "right"] = "hover"
    speed: float = Field(0.0, ge=0, le=100, description="추력 또는 속도 (%)")
    speed_type: Literal["percent"] = "percent"

# --- 드론 제어 로직 클래스 ---
class DroneController:
    """검증된 명령을 바탕으로 드론의 움직임을 제어"""
    def __init__(self, drone: System):
        self.drone = drone
        self.logger = logging.getLogger(self.__class__.__name__)
        self.is_offboard = False

    async def start_offboard_mode(self):
        await self.drone.offboard.set_attitude(attitude=[1.0, 0.0, 0.0, 0.0])
        try:
            await self.drone.offboard.start()
            self.is_offboard = True
            self.logger.info("Offboard 모드 시작 완료!")
        except Exception as e:
            self.is_offboard = False; self.logger.error(f"Offboard 모드 시작 실패: {e}")

    async def send_command(self, command: ControlCommand):
        if not self.is_offboard: return
        
        hover_thrust = 0.5
        max_thrust_offset = 0.15  # 호버링 기준 가감되는 추력의 최대치 (안전 마진)
        thrust = hover_thrust
        
        # 50%를 호버링 기준으로, 그 이상/이하를 상승/하강 추력으로 변환
        thrust_offset = ((command.speed - 50) / 50.0) * max_thrust_offset
        thrust = hover_thrust + thrust_offset
        thrust = max(0.0, min(1.0, thrust)) # 추력 값 범위를 0~1로 제한
        
        self.logger.info(f"명령 실행: vertical={command.vertical}, thrust={thrust:.2f}")
        # MAVSDK Offboard 모드에서 추력을 제어하려면 자세(Attitude)와 함께 보내야 합니다.
        # 여기서는 수직 이동만 하므로 기본 자세(roll=0, pitch=0, yaw=0)를 유지합니다.
        await self.drone.offboard.set_attitude_thrust(attitude=[1.0, 0.0, 0.0, 0.0], thrust_value=thrust)

    async def stop(self):
        if not self.is_offboard: return
        await self.drone.offboard.set_attitude_thrust(attitude=[1.0, 0.0, 0.0, 0.0], thrust_value=0.5)

# --- 메인 실행 로직 ---
async def main():
    """통합 제어 시스템 메인 루프"""
    # 실제 환경에 맞게 연결 문자열과 UART 포트 수정
    connection = DroneConnection("udp://:14540") # 예: "serial:///dev/ttyAMA0:921600"
    uart = UnifiedUARTComm("/dev/tty.usbmodem14101") # 예: "/dev/ttyTHS0"
    
    if not await connection.connect(): return
    if not uart.start(): return
    
    controller = DroneController(connection.drone)
    
    async def communication_loop():
        """텔레메트리 송신 및 원격 제어 명령 수신/처리를 담당"""
        while True:
            # 1. 텔레메트리 데이터 UART로 송신 (1초마다)
            if connection.latest_telemetry:
                payload = {
                    'position': vars(connection.latest_telemetry.get('position', {})),
                    'attitude': vars(connection.latest_telemetry.get('attitude', {})),
                    'battery': vars(connection.latest_telemetry.get('battery', {})),
                }
                uart.send_data("TELEMETRY", payload)
            
            # 2. UART로부터 원격 제어 명령 수신 (옵션)
            raw_cmd = uart.get_command()
            if raw_cmd:
                try:
                    cmd_data = json.loads(raw_cmd).get('command', {})
                    command_obj = ControlCommand(**cmd_data)
                    logging.info(f"원격 명령 수신: {command_obj.model_dump()}")
                    await controller.send_command(command_obj)
                except (json.JSONDecodeError, ValidationError) as e:
                    logging.error(f"잘못된 원격 명령 수신: {raw_cmd} | 오류: {e}")
            
            await asyncio.sleep(1)

    print("\n[시스템] 드론 컨트롤러가 활성화되었습니다.")
    
    comm_task = asyncio.create_task(communication_loop())

    try:
        # --- 자동 비행 시퀀스 시작 ---
        print("\n[시퀀스] 자동 비행 준비 시작 (시동 및 이륙)")
        await connection.drone.action.arm()
        await connection.drone.action.takeoff()
        await asyncio.sleep(5)
        
        await controller.start_offboard_mode()
        if not controller.is_offboard:
            raise Exception("Offboard 모드 진입 실패, 테스트를 중단합니다.")
        await asyncio.sleep(1)

        # 1. 상승
        print("\n[시퀀스 1/3] 상승 시작 (추력 65%)")
        await controller.send_command(ControlCommand(vertical="up", speed=65))
        await asyncio.sleep(4)

        # 2. 호버링
        print("\n[시퀀스 2/3] 호버링 (추력 50%)")
        await controller.send_command(ControlCommand(vertical="level", speed=50))
        await asyncio.sleep(3)

        # 3. 하강
        print("\n[시퀀스 3/3] 하강 시작 (추력 40%)")
        await controller.send_command(ControlCommand(vertical="down", speed=40))
        await asyncio.sleep(4)
        
        print("\n[시퀀스] 자동 비행 완료.")

    except Exception as e:
        logging.error(f"메인 루프에서 오류 발생: {e}")
    finally:
        logging.info("시스템 종료 절차 시작...")
        if controller.is_offboard:
            await controller.stop()
            await controller.drone.action.land()
        
        comm_task.cancel()
        try:
            await comm_task
        except asyncio.CancelledError:
            pass # 작업 취소는 정상
            
        uart.stop()
        await connection.disconnect()
        print("프로그램이 안전하게 종료되었습니다.")

if __name__ == "__main__":
    # 필요한 라이브러리: pip install mavsdk pyserial pydantic
    asyncio.run(main())
